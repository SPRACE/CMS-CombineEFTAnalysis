/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "HiggsAnalysis/CombinedLimit/interface/Roo1DProcessScaling.h" 

#include <math.h> 
#include "TMath.h" 
#include "RooFormulaVar.h"
#include "RooRealVar.h"
#include "RooFit.h"

#include "TFile.h"

ClassImp(Roo1DProcessScaling)

Roo1DProcessScaling::Roo1DProcessScaling() 
{
  initializeProfiles();
}

Roo1DProcessScaling::Roo1DProcessScaling(const char *name, 
							   const char *title,
							   RooAbsReal& _x,
							   RooAbsReal& _operator1,
							   RooAbsReal& _SM_shape,
							   const char * parFilename) :
  operator1("operator1","operator1",this,_operator1),
  profileFilename(parFilename)
{ 

  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(_x);
  bins.clear();
  int N_bins=rdep.getBinning("").numBoundaries();
  double* array = rdep.getBinning("").array();
  for(int i=0; i<N_bins; ++i) {
      bins.push_back(array[i]);
  }

  initializeProfiles();
  initializeNormalization(_x,_SM_shape);

  TFile *f = TFile::Open(parFilename,"READ");
  readProfiles(f);
  f->Close();
} 

Roo1DProcessScaling::
Roo1DProcessScaling(const Roo1DProcessScaling& other, 
		      const char* name) :  
  RooAbsReal(other,name),
  operator1("operator1",this,other.operator1),
  SM_integral(other.SM_integral),
  integral_basis(other.integral_basis),
  bins(other.bins),
  profileFilename(other.profileFilename)
{ 
  initializeProfiles();
  TFile *f = TFile::Open(profileFilename,"READ");  
  readProfiles(f);
  f->Close();
} 

void Roo1DProcessScaling::initializeProfiles() {

  p0.clear();
  p1.clear();
  p2.clear();
 
}

void Roo1DProcessScaling::initializeNormalization(const RooAbsReal& dep,
						  const RooAbsReal& shape) {



  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
  RooRealVar& b = const_cast<RooRealVar&>(rdep);
  
  RooAbsReal* integral = shape.createIntegral(RooArgSet(dep),RooArgSet());
  SM_integral = integral->getVal();
  delete integral;

  int N_bins = bins.size()-1;
  integral_basis.clear();

  for(int i=0; i<N_bins; ++i) {
    int bin_low=bins[i];
    int bin_high=bins[i+1];

    const string intRange="integRange";
    b.setRange((const char*)intRange.c_str(),bin_low,bin_high); //ok

    RooAbsReal* integral = shape.createIntegral(RooArgSet(rdep),RooArgSet(),(const char*)intRange.c_str());
    integral_basis.push_back(integral->getVal());
    delete integral;

  }



}

void Roo1DProcessScaling::readProfiles(TDirectoryFile* dir) const {


  p0.clear(); p1.clear(); p2.clear();
  int N_bins=bins.size()-1;
  for(int i=0; i<N_bins; ++i) {
    TF1* theFcn = (TF1*) dir->Get(TString::Format("bin_function_%i",i));
    p0.push_back(theFcn->GetParameter(0));
    p1.push_back(theFcn->GetParameter(1));
    p2.push_back(theFcn->GetParameter(2));
  }

}

void Roo1DProcessScaling::readProfiles(Roo1DProcessScaling const& other) {


  p0.clear(); p1.clear(); p2.clear();
  int N_bins=bins.size()-1;
  for (int i = 0; i<N_bins; ++i) {
    p0.push_back(other.p0[i]);
    p1.push_back(other.p1[i]);
    p2.push_back(other.p2[i]);
  }

}

Roo1DProcessScaling::~Roo1DProcessScaling() {}

Double_t Roo1DProcessScaling::evaluate() const 
{ 

  double v1(0.0);
  v1 = operator1;

  double ret(0.);

  int N_bins=bins.size()-1;
  for(Int_t i=0 ; i<N_bins ; i++) {
    ret += (p0[i] + p1[i]*v1 + p2[i]*v1*v1)*integral_basis[i];
  }

  return ret/SM_integral;

}

